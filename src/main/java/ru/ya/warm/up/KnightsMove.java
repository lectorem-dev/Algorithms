package ru.ya.warm.up;

import java.util.Scanner;

/*
 * Дана прямоугольная доска NxM. В левом верхнем углу находится шахматный конь, которого необходимо переместить в
 * правый нижний угол доски. В данной задаче конь может перемещаться на две клетки вниз и одну клетку вправо или на
 * одну клетку вниз и две клетки вправо.
 *
 * Необходимо определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний угол.
 *
 * Формат ввода
 * Входной файл содержит два натуральных числа N и M (1 <= N, M <= 50)
 *
 * Формат вывода
 * В выходной файл выведите единственное число — количество способов добраться конём до правого нижнего угла доски.
 * */

public class KnightsMove {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();

        /*
         * Идея решения: проходимся по всей матрице отрезая самую верхнюю и самую нижнюю строки (туда конь попасть не
         * может никак) и просто ищем предположительную позицию коня которая могла его привести в клетку. Если конь там
         * бывал - там уже будет цифра (минимум 1 которую мы оставили на старте потому что туда можно попасть 1 способом)
         * если коня там не было - мы запишем 0. Так проходим всю матрицу и выводим нижнюю левую клетку - если там хоть
         * раз побывал конь - будет число способов как туда попасть. Если клетка не достижима (например матрица 3 на 3)
         * - там будет 0.
         *
         * Time complexity = O(N * M) - потому что там просто два цикла и по две логических проверки. В нашем случае
         * ограничение 50 и в худшем случае будет 2500 итераций
         * Space complexity = O(N * M) - абсолютно аналогично,
         * */

        long[][] chessboard = new long[N][M]; // создаём массив
        chessboard[0][0] = 1L; // обязательно с L, потому что это long

        for (int i = 1; i < N; i++) {
            for (int j = 1; j < M; j++) {

                long from1 = (i >= 2) ? chessboard[i-2][j-1] : 0;
                long from2 = (j >= 2) ? chessboard[i-1][j-2] : 0;

                chessboard[i][j] = from1 + from2;
            }
        }

        System.out.println(chessboard[N-1][M-1]);
    }
}
